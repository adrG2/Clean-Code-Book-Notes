<!DOCTYPE html>
<html>
<head>
<title>Nombres.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="nombres-con-sentido">Nombres con sentido</h1>
<h4 id="nombres-que-revelen-intenciones">Nombres que revelen intenciones</h4>
<p>El nombre de una variable, función o clase debe responder una serie de cuestiones básicas. Debe indicar por qué existe, qué hace y cómo se usa. Si un nombre requiere un comentario, significa que no revela su cometido.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> d; <span class="hljs-comment">//tiempo transcurrido en días</span>
<span class="hljs-keyword">int</span> elapsedTimeInDays;
<span class="hljs-keyword">int</span> daysSinceCreation;
<span class="hljs-keyword">int</span> fileAgeInDays;
</div></code></pre>
<p>En este ejemplo se observa que se necesita un nombre que especifique lo que se mide y la unidad de dicha medida.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Cell&gt; <span class="hljs-title">getFlaggedCells</span><span class="hljs-params">()</span> </span>{
    List&lt;Cell&gt; flaggedCells = <span class="hljs-keyword">new</span> ArrayList&lt;Cell&gt;();
    <span class="hljs-keyword">for</span> (Cell cell : gameBoard)
        <span class="hljs-keyword">if</span> (cell.isFlagged())
            flaggedCells.add(Cell);
        <span class="hljs-keyword">return</span> flaggedCells;
}
</div></code></pre>
<h3 id="evitar-la-desinformaci%C3%B3n">Evitar la desinformación</h3>
<blockquote>
<p>Hay que evitar dejar pistas falsas que dificulten el significado del código.</p>
</blockquote>
<ol>
<li>Nombres de <strong>variables de entorno del sistema</strong></li>
<li>Nombres de un <strong>tipo de dato</strong> cuando esa variable no es de ese tipo</li>
<li><strong>Nombres casi iguales con variaciones mínimas</strong>. Por ejemplo: <code>cambiarPosicionCuadradoArriba</code> con <code>cambiarPosicionTrianguloArriba</code>.</li>
<li><strong>Nombre desinformativo</strong>. Usar <strong>l</strong> minúcula o la <strong>O</strong> mayúscula como nombre de variable puede llevar a la confusión con constantes.</li>
</ol>
<p>No usar la palabra <code>list</code> en una variable salvo que esa variable represente una colección de tipo <code>List</code>. Cambiar: <code>accountList</code> por <code>accounts</code> o <code>accountGroup</code>.</p>
<h4 id="realizar-distinciones-con-sentido">Realizar distinciones con sentido</h4>
<p>No basta con añadir series de números o palabras adicionales con el único objetivo de que el código compile.</p>
<blockquote>
<p>Si los nombres tienen que ser distintos, también deben tener un significado diferente.</p>
</blockquote>
<ol>
<li>
<p><strong>Palabras sin información</strong>. Series numéricas(a1, a2, ... aN).</p>
</li>
<li>
<p><strong>Palabras adicionales</strong>. Clase <code>Product</code> con clase <code>ProductInfo</code> o <code>ProductData</code>. <strong>Info</strong> y <strong>Data</strong> son palabras adicionales, como <strong>a</strong>, <strong>and</strong> y <strong>the</strong>.</p>
</li>
<li>
<p><strong>Prefijos</strong>. Cuando no siguen un convenio pueden desinformar. Usar por ejemplo <code>theZork</code> para nombrar una variable porque en ese ámbito ya está cogida la variable <code>zork</code>.</p>
</li>
<li>
<p><strong>Palabras adicionales redundantes</strong>. La palabra <code>variable</code> no debe incluirse nunca en el nombre de una variable.</p>
</li>
</ol>
<p>Sin convención:</p>
<ul>
<li><code>moneyAmount</code> no se distingue de <code>money</code></li>
<li><code>customerInfo</code> no se distingue de <code>customer</code></li>
<li><code>accountData</code> no se distingue de <code>account</code></li>
<li><code>theMessage</code> no se distingue de message</li>
</ul>
<blockquote>
<p>Se deben diferenciar los nombres de forma que el lector del código aprecie las diferencias.</p>
</blockquote>
<h4 id="nombres-pronunciables">Nombres pronunciables</h4>
<blockquote>
<p>Si no puedes pronunciar el nombre de una variable no podrás explicar lo que hace sin parecer tonto.</p>
</blockquote>
<h4 id="nombres-que-se-puedan-buscar">Nombres que se puedan buscar</h4>
<p>Los nombres de una letra y las constantes numéricas tienen un problema: no son fáciles de localizar en el texto.</p>
<p>Localizar: <code>MAX_CLASSES_PER_STUDENT</code> &gt; 7</p>
<ol>
<li><strong>Número</strong>. Un número puede resultar muy complicado de buscar y por ende de refactorizar.</li>
<li><strong>Nombres monosílabos</strong>. Un nombre de variable como <strong>e</strong> puede ser muy complicado de encontrar. Sólo recomendables usar este tipo de nombres en variables locales.</li>
</ol>
<p>La longitud de un nombre debe corresponderse al tamaño de su ámbito [N5]</p>
<blockquote>
<p>Si una variable o constante se usa en varios puntos del código, debe asignarle un nombre que se pueda buscar</p>
</blockquote>
<p>Compara:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">34</span>, j++)
    s += (t[j] * <span class="hljs-number">4</span>) / <span class="hljs-number">5</span>;
</div></code></pre>
<p>con</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> realDaysPerIdealDay = <span class="hljs-number">4</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> WORK_DAYS_PER_WEEK = <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; NUMBER_OF_TASKS; j++) {
    <span class="hljs-keyword">int</span> realTaskDays = taskEstimate[j] * realDaysPerIdealDay;
    <span class="hljs-keyword">int</span> realTaskWeeks = (realdays / WORK_DAYS_PER_WEEK);
    sum += realTaskWeeks;
}

</div></code></pre>
<h4 id="evitar-codificaciones">Evitar codificaciones</h4>
<p>Al codificar información de tipos o ámbitos en un nombre se dificulta la descodificación.</p>
<p>Si alguien nuevo se incorpora tendrá que aprender cómo descifrar la convención que se sigue para nombres.</p>
<h4 id="notaci%C3%B3n-h%C3%BAngara">Notación húngara</h4>
<blockquote>
<p>Evita usar el tipo de dato de la variable en el nombre.</p>
</blockquote>
<p>Hacen más complicado cambiar el nombre o el tipo de una variable o clase. También dificulta la legibilidad del código y pueden hacer que el sistema de codificación confunda al lector: <code>PhoneNumber phoneString;</code></p>
<h4 id="interfaces-e-implementaciones">Interfaces e implementaciones</h4>
<p>El prefijo 'I', tan habitual en los archivos de legado actuales es, en el mejor de los casos, una distracción, y en el peor, un exceso de información.</p>
<p>Si hay que codificar la interfaz o la implementación, mejor esta última.</p>
<p>Interface: <code>ShapeFactory</code></p>
<p>Implementation: <code>ShapeFactoryImpl</code></p>
<h4 id="evitar-asignaciones-mentales">Evitar asignaciones mentales</h4>
<p>Nombres de variales de una sola letra. Son tradicionales en el contexto de un bucle(i, j o k) pero, en otros contextos, es una opción muy pobre: es como un marcador de posición que el lector debe asignar mentalmente a un concepto real.</p>
<h4 id="nombres-de-clase">Nombres de clase</h4>
<blockquote>
<p>El nombre de una clase no deber ser un verbo</p>
</blockquote>
<h4 id="nombres-de-m%C3%A9todos">Nombres de métodos</h4>
<blockquote>
<p>Los métodos deben tener nombres de verbo como <code>postPayment</code> , <code>deletePage</code> o <code>save</code>. Los métodos de acceso, de modificación y los predicados deben tener como nombre su valor y usar como prefijo <code>get</code>, <code>set</code> e <code>is</code>.</p>
</blockquote>
<h4 id="no-se-exceda-con-el-atractivo">No se exceda con el atractivo</h4>
<p>Si los nombres son demasiado inteligentes, sólo los recordará quién lo ha escrito.</p>
<pre class="hljs"><code><div>Claridad &gt; Entretenimiento
</div></code></pre>
<h4 id="una-palabra-por-concepto">Una palabra por concepto</h4>
<blockquote>
<p>Un léxico coherente es una gran ventaja para los programadores que tengan que usar su código.</p>
</blockquote>
<p>Resulta confuso usar <code>fetch</code>, <code>retrieve</code> y <code>get</code> como métodos equivalentes de clases distintas.
Es imposible recordar qué método equivale a cada clase.</p>
<blockquote>
<p>Los nombres de funciones deben ser independientes y coherentes para que pueda elegir el método correcto sin necesidad de búsquedas adicionales.</p>
</blockquote>
<h4 id="no-haga-juegos-de-palabras">No haga juegos de palabras</h4>
<blockquote>
<p>Evite usar la misma palabra con dos fines distintos.</p>
</blockquote>
<p>Ejemplo: método <code>add()</code></p>
<p>Si utilizas el siguiente método <code>add()</code> con un fin equivalente en varias clases:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">(String izquierda, String derecha)</span> </span>{
    <span class="hljs-keyword">return</span> izquierda + derecha;
}
</div></code></pre>
<p>Tendrás un problema a la hora de implementar un método en otra clase para añadir un valor a una colección de tipo List.</p>
<p>Estaríamos ante una diferencia semántica, por lo que deberemos usar un nombre como <code>insert</code> o <code>append</code>.</p>
<p>Si llamamos <code>add</code> al nuevo método sería un <strong>juego de palabras</strong>.</p>
<blockquote>
<p>Nuestro objetivo es facilitar la comprensión del código. Tenemos que ser los responsables de transmitir el significado.</p>
</blockquote>
<h4 id="nombres-de-dominios-de-soluciones">Nombres de dominios de soluciones</h4>
<p>Usa términos informáticos, nombres de patrones y demás.</p>
<p>Nuestros colegas ya conocen lo que eso significa. Por ejemplo:</p>
<p><code>AccountFactory</code> parece indicar que estamos ante una interfaz que implementa el patrón <code>Factory</code>.</p>
<p>Más ejemplos: <code>UserSingleton</code>, <code>StudentQuickSort</code>, <code>JobQueue</code>,...</p>
<h4 id="nombres-de-dominions-de-problemas">Nombres de dominions de problemas</h4>
<blockquote>
<p>Cuando no exista un término de programación para lo que está haciendo, use el nombre del dominio de problemas.</p>
</blockquote>
<h4 id="a%C3%B1adir-contexto-con-sentido">Añadir contexto con sentido</h4>
<blockquote>
<p>Algunos nombres tienen significado por sí mismos, pero la mayoría no. Por ello, debe incluirlos en un contexto, en clases, funciones y espacios de nombres con nombres adecuados. Cuando todo lo demás falle, pueden usarse prefijos como último recurso.</p>
</blockquote>
<p>Variables: <code>street</code>, <code>houseNumber</code>, <code>city</code>, <code>state</code> y <code>zipCode</code>.Parece que forman una dirección. Ahora bien, si <code>state</code> es usado en otro método... ¿cómo distinguirlo? Habría que añadir contexto.</p>
<p>Una forma de añadirlo sería con prefijos tales como: <code>addrState</code> , <code>addrHouseNumber</code>, etc. Aunque la mejor forma de dar contexto es creando la class <code>Address</code>.</p>
<h5 id="variables-en-un-contexto-ambiguo">Variables en un contexto ambiguo</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printGuessStatistics</span><span class="hljs-params">(<span class="hljs-keyword">char</span> candidate, <span class="hljs-keyword">int</span> count)</span> </span>{
    String number;
    String verb;
    String pluralModifier;

    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) {
        number = <span class="hljs-string">"no"</span>;
        verb = <span class="hljs-string">"are"</span>;
        pluralModifier = <span class="hljs-string">"s"</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) {
        number = <span class="hljs-string">"1"</span>;
        verb = <span class="hljs-string">"is"</span>;
        pluralModifier = <span class="hljs-string">""</span>;
    } <span class="hljs-keyword">else</span> {
        number = Integer.toString(count);
        verb = <span class="hljs-string">"are"</span>;
        pluralModifier = <span class="hljs-string">"s"</span>;
    }

    String guessMessage = String.format(<span class="hljs-string">"There %s %s %s%s"</span>, verb, number, candidate, pluralModifier);

    print(guessMessage);
}
</div></code></pre>
<p>Para dividir la función en fragmentos más reducidos necesitamos crear una clase <code>GuessStatisticsMessage</code>. La mejora del contexto hace que el algoritmo sea más limpio y se divida en funciones más reducidas:</p>
<h5 id="variables-con-un-contexto">Variables con un contexto</h5>
<pre class="hljs"><code><div>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuessStatisticsMessage</span> </span>{
        <span class="hljs-keyword">private</span> String number;
        <span class="hljs-keyword">private</span> String verb;
        <span class="hljs-keyword">private</span> String pluralModifier;

        <span class="hljs-function"><span class="hljs-keyword">public</span> Strin <span class="hljs-title">gmake</span><span class="hljs-params">(<span class="hljs-keyword">char</span> candidate, <span class="hljs-keyword">int</span> count)</span> </span>{
            <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"There %s %s %s%s"</span>, verb, number, candidate, pluralModifier);
        }

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createPluralDependentMessageParts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>{
            <span class="hljs-keyword">if</span> ( count == <span class="hljs-number">0</span> ) {
                thereAreNoLetters();
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) {
                thereIsOneLetter();
            } <span class="hljs-keyword">else</span> {
                thereAreManyLetters(count);
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thereAreManyLetters</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>{
            number = Integer.toString(count);
            verb = <span class="hljs-string">"are"</span>;
            pluralModifier = <span class="hljs-string">"s"</span>;
        }

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thereIsOneLetter</span><span class="hljs-params">()</span> </span>{
            number = <span class="hljs-string">"1"</span>;
            verb = <span class="hljs-string">"is"</span>;
            pluralModifier = <span class="hljs-string">""</span>;
        }

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thereAreNoLetters</span><span class="hljs-params">()</span> </span>{
            number = <span class="hljs-string">"no"</span>;
            verb = <span class="hljs-string">"are"</span>;
            pluralModifier = <span class="hljs-string">"s"</span>;
        }
    }
</div></code></pre>
<h4 id="no-a%C3%B1adir-contextos-innecesarios">No añadir contextos innecesarios</h4>
<blockquote>
<p>Los nombres breves suelen ser más adecuados que los extensos, siempre que sean claros.</p>
</blockquote>
<blockquote>
<p>No añada más contexto del necesario a un nombre</p>
</blockquote>
<p>Los nombres <code>accountAddress</code> y <code>customerAddress</code> son perfectos para instancias de la clase <code>Address</code> pero no sirven como nombres de clase.</p>
<p>Para distinguir entre direcciones mac, puertos y web, podría usar: <code>PostalAddress</code>, <code>MAC</code> y <code>URI</code>.</p>
<blockquote>
<p>El objetivo de cualquier nombre es ser más preciso</p>
</blockquote>

</body>
</html>
