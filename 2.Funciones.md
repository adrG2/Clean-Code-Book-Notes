# Funciones

## Tamaño reducido

El objetivo es hacer una función con las mínimas líneas posibles.

Un ejemplo de buen programa sería aquel en el que sus funciones:

1. Tienen 2, 3 o 4 líneas de longitud.

2. Todas ellas deben ser obvias.

3. Todas deben contar una historia y cada una lleva a la siguiente en un orden atractivo.

## Bloques y sangrado

El nivel de sangrado de una función no debe ser mayor de uno o dos. Esto evitaría a toda cosa estructuras anidadas que puedan aumentar el tamaño de la función.

Los bloques de instrucciones como `if`, `else` o `while` sólo deberían tener una línea con la invocación de una función.

```Java
    if(User.isValid()) {
        registerUserCartItems();
    } else {
        userNotValidException();
    }

    while(User.isNotRegistered()) {
        showSuggestionPopUpRegister();
    }
```

## Hacer una cosa

> Las funciones solo deben hacer una cosa. Deben hacerlo bien y debe ser lo único que hagan.

Ejemplo:

```Java
    public static String renderPageWithSetupsAndTeardowns(PageData pageDate, boolean isSuite) {
        if ( isTestPage( pageData ) ) {
            includeSetupAndTeardownPages(pageData, isSuite);
        }
        return pageData.getHtml();
    }
```

**¿Esta función hace una o tres cosas?**

Los tres pasos de la función se encuentran a un nivel de abstracción por debajo del nombre de la función.

Descripción de la función:

_Para `RenderPageWithSetupsAndTeardowns`, comprobamos si la página es de prueba y, en caso afirmativo, incluimos las configuraciones y los detalles. En ambos casos, la representamos en HTML_

> #### Si una función sólo realiza los pasos situados un nivel por debajo del nombre de la función, entonces hace una cosa.

**Creamos funciones para descomponer conceptos más amplios en un conjunto de pasos en el siguiente nivel de abstracción.**

Otra forma de saber que una función hace más de una cosa es **extraer otra función de la misma con un nombre que no sea una reducción de su implementación.**

Es evidente que una función hace más de una cosa cuando se divide en secciones como declaraciones, inicializaciones y filtros.

**Las funciones que hace una sola cosa no se pueden dividir en secciones.**

## Un nivel de abstracción por función

> **Las instrucciones de una función siempre se tienen que encontrar en el mismo nivel de abstracción.**

## Leer código de arriba a abajo: la regla descendente

Todas las funciones deben estar jerarquizadas de mayor a menor por su nivel de abstracción.

Queremos leer el programa como si fuera un conjunto de párrafos TO, en el que cada uno describe el nivel actual de abstracción y hace referencia a los párrafos TO posteriores en el siguiente nivel.

## Instrucciones Switch

Es muy complicado usar una instrucción `switch` de tamaño reducido.

A veces es inevitable su uso, así que lo único que podemos hacer es asegurarnos de incluirlas en una clase de nivel inferior y no repetirlas. Para ello, hay que recurrir al polimorfismo.

Ejemplo:

```Java
    public Position calculatePosition (Player e) {
        switch (e.type) {
            case PIVOT:
                return calculateRebounds(e);
            case POINT_GUARD:
                return calculateAssists(e);
            case SHOOTING_GUARD:
                return calculatePoints(e);
            default:
                throw new InvalidPlayerType(e.type);
        }
    }
```

Problemas de esta función:

1. **Gran tamaño** y cuando se añadan nuevos tipos de empleado, aumentará más.
2. **Hace más de una cosa**.
3. Incumple **Principio de Responsabilidad única(SRP)**.
4. Incumple **Principio de Abierto/Cerrado(OCP)** ya que esta función cambiará cuando se añadan nuevos tipos. Pero el mayor problema es que hay otras funciones como `isHeadline(Player e, Date date)` o `getSalary(Player e)` que tendrán la misma estructura.

Mi regla general para las instrucciones `switch` es que se pueden tolerar si solo aparecen una vez, se usan para crear objetos polimórficos y se ocultan tras una relación de herencia para que el resto del sistema no las pueda ver.

Ejemplo de solución mediante Factoría Abstracta:

```Java
    public abstract class Player {
        public abstract boolean isHeadline();
        public abstract Position calculatePosition();
        public abstract Salary getSalary(Player e);
    }

    public interface PlayerFactory {
        public Player makePlayer (PlayerRecord r);
    }

    public class PlayerFactoryImpl implements PlayerFactory {
        public Player makePlayer (PlayerRecord r) {
            switch (r.type) {
                case PIVOT:
                    return new PivotPlayer(r);
                case POINT_GUARD:
                    return new PointGuardPlayer(r);
                case SHOOTING_GUARD:
                    return new ShootingGuardPlayer(r);
                default:
                    throw new InvalidPlayerType(r.type);
            }
        }
    }
```

## Usar nombres descriptivos
