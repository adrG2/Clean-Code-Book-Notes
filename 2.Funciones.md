# Funciones

## Tamaño reducido

El objetivo es hacer una función con las mínimas líneas posibles.

Un ejemplo de buen programa sería aquel en el que sus funciones:

1. Tienen 2, 3 o 4 líneas de longitud.

2. Todas ellas deben ser obvias.

3. Todas deben contar una historia y cada una lleva a la siguiente en un orden atractivo.

## Bloques y sangrado

El nivel de sangrado de una función no debe ser mayor de uno o dos. Esto evitaría a toda cosa estructuras anidadas que puedan aumentar el tamaño de la función.

Los bloques de instrucciones como `if`, `else` o `while` sólo deberían tener una línea con la invocación de una función.

```Java
    if(User.isValid()) {
        registerUserCartItems();
    } else {
        userNotValidException();
    }

    while(User.isNotRegistered()) {
        showSuggestionPopUpRegister();
    }
```

## Hacer una cosa

> Las funciones solo deben hacer una cosa. Deben hacerlo bien y debe ser lo único que hagan.

Ejemplo:

```Java
    public static String renderPageWithSetupsAndTeardowns(PageData pageDate, boolean isSuite) {
        if ( isTestPage( pageData ) ) {
            includeSetupAndTeardownPages(pageData, isSuite);
        }
        return pageData.getHtml();
    }
```

**¿Esta función hace una o tres cosas?**

Los tres pasos de la función se encuentran a un nivel de abstracción por debajo del nombre de la función.

Descripción de la función:

_Para `RenderPageWithSetupsAndTeardowns`, comprobamos si la página es de prueba y, en caso afirmativo, incluimos las configuraciones y los detalles. En ambos casos, la representamos en HTML_

> #### Si una función sólo realiza los pasos situados un nivel por debajo del nombre de la función, entonces hace una cosa.

**Creamos funciones para descomponer conceptos más amplios en un conjunto de pasos en el siguiente nivel de abstracción.**

Otra forma de saber que una función hace más de una cosa es **extraer otra función de la misma con un nombre que no sea una reducción de su implementación.**

Es evidente que una función hace más de una cosa cuando se divide en secciones como declaraciones, inicializaciones y filtros.

**Las funciones que hace una sola cosa no se pueden dividir en secciones.**

## Un nivel de abstracción por función

> **Las instrucciones de una función siempre se tienen que encontrar en el mismo nivel de abstracción.**

## Leer código de arriba a abajo: la regla descendente

Todas las funciones deben estar jerarquizadas de mayor a menor por su nivel de abstracción.

Queremos leer el programa como si fuera un conjunto de párrafos TO, en el que cada uno describe el nivel actual de abstracción y hace referencia a los párrafos TO posteriores en el siguiente nivel.

## Instrucciones Switch

Es muy complicado usar una instrucción `switch` de tamaño reducido.

A veces es inevitable su uso, así que lo único que podemos hacer es asegurarnos de incluirlas en una clase de nivel inferior y no repetirlas. Para ello, hay que recurrir al polimorfismo.

Ejemplo:

```Java
    public Position calculatePosition (Player e) {
        switch (e.type) {
            case PIVOT:
                return calculateRebounds(e);
            case POINT_GUARD:
                return calculateAssists(e);
            case SHOOTING_GUARD:
                return calculatePoints(e);
            default:
                throw new InvalidPlayerType(e.type);
        }
    }
```

Problemas de esta función:

1. **Gran tamaño** y cuando se añadan nuevos tipos de empleado, aumentará más.
2. **Hace más de una cosa**.
3. Incumple **Principio de Responsabilidad única(SRP)**.
4. Incumple **Principio de Abierto/Cerrado(OCP)** ya que esta función cambiará cuando se añadan nuevos tipos. Pero el mayor problema es que hay otras funciones como `isHeadline(Player e, Date date)` o `getSalary(Player e)` que tendrán la misma estructura.

La regla general para las instrucciones `switch` es que se pueden tolerar si solo aparecen una vez, se usan para crear objetos polimórficos y se ocultan tras una relación de herencia para que el resto del sistema no las pueda ver.

Ejemplo de solución mediante **Factoría Abstracta**:

```Java
    public abstract class Player {
        public abstract boolean isHeadline();
        public abstract Position calculatePosition();
        public abstract Salary getSalary(Player e);
    }

    public interface PlayerFactory {
        public Player makePlayer (PlayerRecord r);
    }

    public class PlayerFactoryImpl implements PlayerFactory {
        public Player makePlayer (PlayerRecord r) {
            switch (r.type) {
                case PIVOT:
                    return new PivotPlayer(r);
                case POINT_GUARD:
                    return new PointGuardPlayer(r);
                case SHOOTING_GUARD:
                    return new ShootingGuardPlayer(r);
                default:
                    throw new InvalidPlayerType(r.type);
            }
        }
    }
```

## Usar nombres descriptivos

> **Ward**:"Sabemos que trabajamos con código limpio cuando cada rutina es más o menos lo que esperábamos".

Para alcanzar este principio, gran parte del esfuerzo se basa en seleccionar nombres adecuados para pequeñas funciones que hacen una cosa. Cuanto más reducida y concreta es una función más fácil es elegir un nombre descriptivo.

Los nombres descriptivos clarifican el diseño de los módulos y permiten su mejora. Una búsqueda de nombres adecuados suele generar una reestructuración favorable del código.

**Coherencia en los nombres**: usa las mismas frases, sustantivos y verbos en los nombres de función que elija para los módulos.

Ejemplo:

-   `includeSetupAndTeardownPages`
-   `includeSetupPages`
-   `includeSuiteSetupPage`
-   `includeSetupPage`
-   `includeTeardownPages`
-   `includeSuiteTeardownPage`
-   `includeTeardownPage`

**La estructura general de estos nombres permite que la secuencia cuente una historia**

## Argumentos de funciones

> #### El número ideal de argumentos para una función es cero.

Siempre que sea posible hay que evitar la presencia de 3 o más argumentos.

El argumento se encuentra en un nivel de abstracción diferente respecto al nombre de la función y nos obliga a conocer un detalle.

A mayor número de argumentos más complicado es el desarrollo de tests ya que hay que buscar diferentes combinaciones de argumentos para testear correctamente la función.

Los argumentos de salida son más difíciles de entender que los de entrada.

Función:

-   **Información añadida**: argumentos
-   **Información extraída**: valor devuelto

No esperamos que la información se devuelva a través de los argumentos. Por ello, los argumentos de salida suelen obligarnos a realizar una comprobación doble.

### Funciones de 1 argumento habituales

Hay 2 motivos principales para pasar un solo argumento a una función:

1. Se realiza una pregunta sobre el argumento. Ejemplo: `boolean fileExists ("Test.txt")`.
2. Procesamiento sobre el argumento, lo transforma en otra cosa y lo devuelve. Ejemplo: `InputStream fileOpen ("Test.txt")`. Esta función transforma un nombre de archivo `String` en un valor devuelto de tipo `InputStream`.

Otro caso de uso para usar un único argumento es un **evento**. Hay un agumento de entrada pero ninguno de salida.

El programa debe interpretar la invocación de la función como evento y usar el argumento para alterar el estado del sistema. Ejemplo: `void passwordAttemptFailedNtimes (int attemps)`. Se entiende que esta función modifica valores de estado del sistema cuando el evento("Superar número de intentos de acceso") ocurre. Seguramente esta función llame a otra que se ocupa de este tipo de caso de uso como podría ser `blockerUserExceptionTreat()` que se ocupará probablemente del tratamiento de una excepción.

Evitar este tipo de funciones: `void includeSetupPageInto ( StringBuffer pageText )`. El uso de un argumento de salida en lugar de un valor devuelto para realizar **transformaciones** resulta confuso.

> **Si una función va a transformar su argumento de entrada, la transformación debe aparecer como valor devuelto.**

#### Argumentos de indicador

Los argumentos de indicador son horribles. Pasar un valor `boolean` a una función es una práctica totalmente desaconsejable. **Complica la declaración del método e indica que la función hace más de una cosa**. Hace algo si es `true` y otra cosa si es `false`.

Ejemplo:

-   Invocación: `chekIn(true)`
-   Declaración: `checkIn(boolean company)`

Para que esto quede más limpio:

-   `checkInCompany()`
-   `checkInPrivateClient()`

### Funciones de 2 argumentos

Una función con dos argumentos es más difícil de entender que una función con un argumento.

Ejemplo: `writeField(name)` y `writeField(outputStream, name)`.

La segunda forma nos hace pararnos hasta que ignoramos el parámetro `outputStream`, lo cual nos generará problemas puesto que **las partes que ignoramos son las que esconden los errores**.

**En ocasiones se necesitan usar dos argumentos**

Ejemplo: Puntos cartesianos en `public Point(int x, int y)`. En este caso ambos argumentos son componentes ordenados de un mismo valor, mientras que `outputStream` y `name` carecen de una cohesión o un orden natural.

Ejemplo: `assertEquals(expected, actual)`. **¿Cuántas veces te has confundido y has puesto al revés los valores?** Ambos argumentos carecen de un orden natural, están impuestos a criterio del desarrollador. No es algo que se sobreentienda por convención como es el caso de los puntos cartesianos.

**Mecanismos disponibles para convertir una función de dos argumentos en uno**:

-   Convertir método `writeField` a miembro de `outputStream` para usar `outputStream.writeField(name)`.
-   Convertir `outputStream` en un atributo de la clase actual para no tener que pasarlo como argumento.

    Ejemplo:

    ```Java
        class CreateHtml {
            private OutputStream outputStream;

            public static OutputStream writeField(String name) {
                // Code
            }
        }
    ```

-   Extraer una nueva clase como `FieldWriter` que usara `outputStream` en su constructor y tuviera un método `write()`.

    Ejemplo:

    ```Java
        class FieldWriter {
            private OutputStream outputStream;

            public FieldWriter(String name) {
                outputStream = new OutputStream();
            }

            public OutputStream write() {
                // Code
            }
        }
    ```

### Funciones de 3 argumentos

Los problemas a la hora de ordenar, ignorar o detenerse en los argumentos se duplican.

Ejemplo: `assertEquals(message, expected, actual)`

## Objeto de argumento

Cuando una función parece necesitar 2 o más argumentos, es probable que alguno de ellos se incluya en una clase propia.

Ejemplo:

-   `Circle makeCircle(double x, double y, double radius);`
-   `Circle makeCircle(Point center, double radius);`

Cuando se pasan grupos de variables de forma conjunta, como `x` e `y`, es probable que formen parte de un concepto que se merece un nombre propio en forma de objeto.

## Listas de argumentos

Si los argumentos variables se procesan de la misma forma serán equivalentes a un único argumento de tipo `List`.

Ejemplo: `public String format(String format, Object ...args);`

Invocación: `phrase.format("%.2f hours %s nameCompany %s nameStreet", hours, nameCompany, nameStreet);`

## Verbos y palabras clave

La selección de nombres correctos para una función mejora la explicación de su cometido así como el orden y el cometido de los argumentos.

Función de 1 argumento: la función y el argumento deben formar un par de verbo y sustantivo. Ejemplo: `writeField(name)`. Nos indica que name es un campo y que lo vamos a escribir. Esto sería un ejemplo de palabra clave como nombre de función.

Con este formato codificamos los nombres de los argumentos en el nombre de la función.

Ejemplo: `assertEquals` por `asssertExpectedEqualsActual(expected, actual)`. Esto solucionaría el problema de tener que recordar el orden de los argumentos.

## Sin efectos secundarios
